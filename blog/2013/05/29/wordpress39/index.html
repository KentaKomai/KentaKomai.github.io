
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>[Ruby Python]正規表現に関しておさらい - KentaKomai's BLOG</title>
  <meta name="author" content="Kenta Komai">

  
  <meta name="description" content="正規表現ってかなり頻繁に使うのに、なかなか一発で書けなくて、その度に調べてる気がするので、ここでちょっとまとめてみようと思いました。 個人的に最近よく利用するRubyとPythonでやってみようかな、と思ってます。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://KentaKomai.github.io/blog/2013/05/29/wordpress39">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="KentaKomai's BLOG" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
  

</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner">
	<div class="header-title"><a href="/">KentaKomai's BLOG</a></div>


	<br><div class="header-subtitle">自分用備忘録の延長</div>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:KentaKomai.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
  
    
      <h1 class="entry-title">[Ruby Python]正規表現に関しておさらい</h1>
    
  
    
      <p class="meta">
        








  


<time datetime="2013-05-29T00:00:00+09:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>正規表現ってかなり頻繁に使うのに、なかなか一発で書けなくて、その度に調べてる気がするので、ここでちょっとまとめてみようと思いました。</p>

<p>個人的に最近よく利用するRubyとPythonでやってみようかな、と思ってます。</p>

<p>pythonに関しては公式で正規表現のサンプルがのったリファレンスがあったのでリンク貼っておきます</p>

<p><a href="http://docs.python.jp/3/howto/regex.html#regex-howto">http://docs.python.jp/3/howto/regex.html#regex-howto</a></p>

<h4>0.まずはとりあえず使ってみる</h4>

<p>[Ruby]</p>

<pre class="lang:ruby decode:true"># coding:utf-8

str = "hello"
r = Regexp.new(/h.*o/)

if /h.*o/ =~ str
    p "match!"
else
    p "no match..."
end

if r =~ str
    p "match!!"
else
    p "oh...no match..."
end</pre>


<p>インポートは特別必要ないみたいです。明示的にインスタンスを生成したければRegexp.new(/パターン/)、文字リテラル（1つ目のif文の箇所）でそのままでもOKです。 コンストラクタに与える引数は/(スラッシュ)で囲っても、クォーテーションで囲ってもOKです。</p>

<p>あと、 =~ ってどういう演算子なんだろう・・・と調べてたんですが、これはRegexpクラスのパターンマッチを行うメソッドでした。</p>

<p>ちなみに上記のif文は二つともマッチングします。</p>

<p>[Python]</p>

<pre class="lang:python decode:true"># coding:utf-8

import re

def main():
    str = "hello"
    p = re.compile("h.*o")
    m = p.match(str)

    if m != None:
        print "match!"
    else:
        print "no match..."

if __name__ == "__main__":
    main()</pre>


<p>対してPythonはre モジュールのインポートが必要になります。</p>

<p>re.compile(&#8220;パターン&#8221;)でインスタンスを生成できます。Pythonのマッチングのチェックには４つのメソッドがあって</p>

<p>・match()　文字列の先頭からマッチするかチェック</p>

<p>・search()　文字列を全体から、どこにマッチするかをチェック</p>

<p>・findall()　文字列内のマッチする箇所全てをリストにして返す</p>

<p>・finditer　文字列内のマッチする箇所全てをイテレータとして返す</p>

<p>上記のサンプルでは&#8221;hello&#8221;をmatch()でチェックしマッチングしますが、例えば&#8221;Bob, hello!&#8221;など、文の頭からマッチングしていなければNoneが帰ってきます。findallは後で試しますが、文章中から特定の文字列 のマッチングをしたいときはsearch()のほうがよさそうです。</p>

<p>&nbsp;</p>

<h4>1.特定の文字列パターンにマッチさせる</h4>

<p>前項で既に簡単なサンプルを挙げてしまいましたが、もうちょっと使えそうなやつを・・・・。</p>

<p>んー、でも使えるやつってなんでしょ・・・ｗEメールのマッチングとか、便利なんですけど、ちょっと難易度高いので</p>

<p>・base64に使われている文字列をマッチングさせる</p>

<p>・URL全体からドメイン名をマッチングさせる</p>

<p>の二種類を試します。これRubyとPythonの正規表現、じゃなくて普通に正規表現のはなしになってるかな・・・。まぁよく覚えてないので、そこも含めて復習します・・・。</p>

<p>&nbsp;</p>

<p>base64に使われている文字は大文字AからZと小文字aからz、数字の１から９、そして記号の+,/,=です。この文字列のみを含むものと、そうでないものをマッチングさせてみます。</p>

<p>[Ruby]</p>

<pre class="lang:ruby decode:true"># coding:utf-8
#
if ARGV.size != 1
    p "usage: " &lt;&lt; $0 &lt;&lt; " " &lt;&lt; "&lt;string&gt;"
    exit
end

str = ARGV[0]
reg = Regexp.new(/^[A-Za-z0-9\/+]*=*$/)

if reg =~ str
    p "match!"
else
    p "no match..."
end</pre>


<p>引数に与えた文字列がbase64のものであればマッチングします。（多分間違ってないよね・・・？）</p>

<p>rubyはRailsでの開発で使っただけだったので、コマンドライン引数を取得するところから調べました・・・ｗ</p>

<p>&nbsp;</p>

<p>[Python]</p>

<pre class="lang:default decode:true"># coding:utf-8

import re
import sys

def main():

    argvs = sys.argv
    if len(argvs) is 1:
        print "usage: ",argvs[0], "&lt;string&gt;"
        exit()

    str = argvs[1]
    p = re.compile(r"^[A-Za-z0-9\/+]*=*$")
    m = p.search(str)

    if m is None:
        print "no match..."
    else:
        print "match!!"

if __name__ == "__main__":
    main()</pre>


<p>コマンドライン引数を得るために、sysモジュールをインポートしてあります。</p>

<p>あとはほとんどRubyと同じ。ひとつポイントは</p>

<pre>p = re.compile(r"^[A-Za-z0-9\/+]*=*$")</pre>


<p>の箇所。パターンの前に小文字のrがありますね。ちゃんとした説明やrをつける理由は一番上に貼ったリンクにありますが、すごく簡単にいうと、正規表現のパターンを宣言するときはrつけると簡単、って感じ。</p>

<p>※公式でも「実行遅いけど、読みやすく簡単だよ！」という触れ込み（笑）</p>

<p>&nbsp;</p>

<p>次はドメインをマッチングしたいと思います。</p>

<p>下記の条件にマッチングさせてみます</p>

<p>１．<a href="http://tamago.servehttp.com/blog/%E3%81%AF%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0%E3%81%97%E3%81%AA%E3%81%84">http://tamago.servehttp.com/blog/%E3%81%AF%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0%E3%81%97%E3%81%AA%E3%81%84</a></p>

<p>２．<a href="http://tamago.servehttp.com%E3%81%AB%E3%81%AF%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0%E3%81%99%E3%82%8B">http://tamago.servehttp.com%E3%81%AB%E3%81%AF%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0%E3%81%99%E3%82%8B</a></p>

<p>[Ruby]</p>

<pre class="lang:ruby decode:true"># coding:utf-8
#

if ARGV.size != 1
    p "usage: " &lt;&lt; $0 &lt;&lt; " " &lt;&lt; "&lt;string&gt;"
    exit
end

str = ARGV[0]
reg = Regexp.new(/^(https?|ftp):\/\/[A-Za-z0-9\.]*$/)

if reg =~ str
    p "match!"
else
    p "no match..."
end</pre>


<p>[python]</p>

<pre class="lang:python decode:true"># coding:utf-8

import re
import sys

def main():

    argvs = sys.argv
    if len(argvs) is 1:
        print "usage: ",argvs[0], "&lt;string&gt;"
        exit()

    str = argvs[1]
    p = re.compile(r"^(https?|ftp):\/\/[A-Za-z0-9\.\-]*$")
    m = p.search(str)

    if m is None:
        print "no match..."
    else:
        print "match!!"

if __name__ == "__main__":
    main()</pre>


<p>こんな感じでいいかな・・・・？とりあえず上記の条件はパスできました。</p>

<p>次からは、文章中からURLや任意の文字パターンを抜き出してみたいと思います。</p>

<p>正規表現に関しては比較するとRubyのほうがコード少なくて済みますね。</p>

<p>&nbsp;</p>

<h4>2.文字列パターンにマッチした文字列を抜き出す</h4>

<p>[Ruby]</p>

<p>パターンにマッチングした文字列を抜き出すにはStringクラスのscanメソッドを利用します。(それ以外だと$0とかの方法があるみたいですが、簡単で、かつ僕の用途に合ってるのはscanだったので、こちらを選びました。)</p>

<pre class="lang:ruby decode:true"># coding:utf-8
#

if ARGV.size != 1
    p "usage: " &lt;&lt; $0 &lt;&lt; " " &lt;&lt; "&lt;string&gt;"
    exit
end

str = ARGV[0]
m = str.scan(/(?:https?|ftp):\/\/[A-Za-z0-9\.]*/)

if m.size != 0
    p m
else
    p "no match...."
end</pre>


<p>マッチングした箇所を抽出することを後方参照と言うらしいのですが、ここでポイントが</p>

<pre>(/(?:https?|ftp):\/\/[A-Za-z0-9\.]*/)</pre>


<p>http,https,ftpのいずれかをマッチングするためのグルーピングがされていますが、頭に?:がついています。これは後方参照をしない、という意味です。</p>

<p>これをしないと、例えば<a href="http://www.facebook.com%E3%82%92%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0%E3%81%95%E3%81%9B%E3%81%9F%E3%81%A8%E3%81%8D%E3%81%AB%E3%80%81%E5%BE%8C%E6%96%B9%E5%8F%82%E7%85%A7%E3%82%92%E8%A1%8C%E3%81%86%E3%81%A8%E3%80%81http://www.facebook.com%E3%81%A8http%E3%81%AE%E4%BA%8C%E3%81%A4%E3%81%8C%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0%E3%81%97%E3%81%A6%E3%81%97%E3%81%BE%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E6%8A%9C%E3%81%8D%E5%87%BA%E3%81%97%E3%81%9F%E3%81%84%E3%81%AE%E3%81%AFhttp://www.facebook.com%E3%81%A0%E3%81%91%E3%81%AA%E3%81%AE%E3%81%A7%E3%80%81%E6%9C%80%E5%88%9D%E3%81%AE%E3%82%B0%E3%83%AB%E3%83%BC%E3%83%94%E3%83%B3%E3%82%B0%E3%81%AB%E3%81%AF%E6%98%8E%E7%A4%BA%E7%9A%84%E3%81%AB%E5%BE%8C%E6%96%B9%E5%8F%82%E7%85%A7%E3%81%8C%E4%B8%8D%E8%A6%81%E3%81%A0%E3%81%A8%E3%81%84%E3%81%86%E3%81%93%E3%81%A8%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%97%E3%81%BE%E3%81%99%E3%80%82">http://www.facebook.com%E3%82%92%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0%E3%81%95%E3%81%9B%E3%81%9F%E3%81%A8%E3%81%8D%E3%81%AB%E3%80%81%E5%BE%8C%E6%96%B9%E5%8F%82%E7%85%A7%E3%82%92%E8%A1%8C%E3%81%86%E3%81%A8%E3%80%81http://www.facebook.com%E3%81%A8http%E3%81%AE%E4%BA%8C%E3%81%A4%E3%81%8C%E3%83%9E%E3%83%83%E3%83%81%E3%83%B3%E3%82%B0%E3%81%97%E3%81%A6%E3%81%97%E3%81%BE%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E6%8A%9C%E3%81%8D%E5%87%BA%E3%81%97%E3%81%9F%E3%81%84%E3%81%AE%E3%81%AFhttp://www.facebook.com%E3%81%A0%E3%81%91%E3%81%AA%E3%81%AE%E3%81%A7%E3%80%81%E6%9C%80%E5%88%9D%E3%81%AE%E3%82%B0%E3%83%AB%E3%83%BC%E3%83%94%E3%83%B3%E3%82%B0%E3%81%AB%E3%81%AF%E6%98%8E%E7%A4%BA%E7%9A%84%E3%81%AB%E5%BE%8C%E6%96%B9%E5%8F%82%E7%85%A7%E3%81%8C%E4%B8%8D%E8%A6%81%E3%81%A0%E3%81%A8%E3%81%84%E3%81%86%E3%81%93%E3%81%A8%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%97%E3%81%BE%E3%81%99%E3%80%82</a></p>

<p>なので、上記のサンプルはhttp,https,ftpのいずれかで始まり、::/の後に大文字A-Z小文字a-z、そして数字の1-9、ドットが含まれる文字列にマッチングします。</p>

<p>&nbsp;</p>

<p>[Python]</p>

<p>Pythonではマッチングした文字列を抽出するには、group()メソッドを呼びます。</p>

<p>先ほどのコードを少しいじるだけ+ findall()を使ってみます。マッチした全ての文字列をリストで返すので、使いやすいかなと思います。</p>

<pre class="lang:default decode:true"># coding:utf-8

import re
import sys

def main():

    argvs = sys.argv
    if len(argvs) is 1:
        print "usage: ",argvs[0], "&lt;string&gt;"
        exit()

    str = argvs[1]
    p = re.compile(r"(?:https?|ftp):\/\/[A-Za-z0-9\.-]*")
    m = p.findall(str)

    if len(m) is 0:
        print "no match..."
    else:
        for n in m:
            print n

if __name__ == "__main__":
    main()</pre>


<p>変数名もうちょっとマシなのつけたほうが良かったかな・・・。さーせんｗ</p>

<p>後方参照にマッチさせない書き方はRubyと一緒ですね。よかった。</p>

<p>&nbsp;</p>

<h4>3.文字列パターンにマッチした文字列を置き換える</h4>

<p>今度はマッチングした文字列のなかから、特定の箇所を置換えてみます。結局何がしたかったか、というと、渡された文字列からURLを抜き出して、それからhttpとかのプロトコルの部分を消す、ということをしたかったのです。</p>

<p>さっき抜き出したのが<a href="http://www.facebook.com%E3%81%AA%E3%81%AE%E3%81%A7%E3%80%81%E6%9C%80%E7%B5%82%E7%9A%84%E3%81%AB%E3%81%AFwww.facebook.com%E3%81%A8%E3%81%84%E3%81%86%E5%BD%A2%E5%BC%8F%E3%81%AB%E3%81%97%E3%81%A6%E3%81%84%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82">http://www.facebook.com%E3%81%AA%E3%81%AE%E3%81%A7%E3%80%81%E6%9C%80%E7%B5%82%E7%9A%84%E3%81%AB%E3%81%AFwww.facebook.com%E3%81%A8%E3%81%84%E3%81%86%E5%BD%A2%E5%BC%8F%E3%81%AB%E3%81%97%E3%81%A6%E3%81%84%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82</a></p>

<p>これ、正規表現に詳しい人なら一撃で文字列からwww.facebook.comを抽出することもできるのかもしれませんが、段階を踏んで簡単にできる方法として、<a href="http://%E3%81%AA%E3%81%A9%E3%82%92%E6%8C%87%E6%A8%99%E3%81%AB%E3%81%BE%E3%81%9A%E3%81%AF%E6%8A%BD%E5%87%BA%E3%81%97%E3%82%88%E3%81%86%E3%81%A8%E8%80%83%E3%81%88%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82">http://%E3%81%AA%E3%81%A9%E3%82%92%E6%8C%87%E6%A8%99%E3%81%AB%E3%81%BE%E3%81%9A%E3%81%AF%E6%8A%BD%E5%87%BA%E3%81%97%E3%82%88%E3%81%86%E3%81%A8%E8%80%83%E3%81%88%E3%81%BE%E3%81%97%E3%81%9F%E3%80%82</a></p>

<p>置換えにはStringクラスのgsubメソッドを利用します。</p>

<pre class="lang:ruby decode:true"># coding:utf-8
#

if ARGV.size != 1
    p "usage: " &lt;&lt; $0 &lt;&lt; " " &lt;&lt; "&lt;filepath&gt;"
    exit
end

filepath = ARGV[0]
f = open(filepath)
str = f.read
# reg = Regexp.new(/^(https?|ftp):\/\/[A-Za-z0-9\.]*$/)
ms = str.scan(/(?:https?|ftp):\/\/[A-Za-z0-9\.]*/)

if ms.size != 0
    ms.each do |m|
        p m.gsub(/(?:https?|ftp):\/\//, '')
    end
else
    p "no match...."
end</pre>


<p>コマンドライン引数にファイルパスを指定してやると、その中からドメインを抜き出します。</p>

<p>gsubの使い方はscanと変わりません。第二引数に置換え後の文字列を与えるだけです。今回は<a href="http://%E3%81%AA%E3%81%A9%E3%82%92%E6%B6%88%E3%81%97%E3%81%9F%E3%81%84%E3%81%AE%E3%81%A7%E3%80%81%E7%AC%AC%E4%BA%8C%E5%BC%95%E6%95%B0%E3%81%AF%E7%A9%BA%E3%81%A7%E3%81%99%E3%80%82">http://%E3%81%AA%E3%81%A9%E3%82%92%E6%B6%88%E3%81%97%E3%81%9F%E3%81%84%E3%81%AE%E3%81%A7%E3%80%81%E7%AC%AC%E4%BA%8C%E5%BC%95%E6%95%B0%E3%81%AF%E7%A9%BA%E3%81%A7%E3%81%99%E3%80%82</a></p>

<p>&nbsp;</p>

<p>[Python]</p>

<pre class="lang:default decode:true"># coding:utf-8

import re
import sys

def main():

    argvs = sys.argv
    if len(argvs) is 1:
        print "usage: ",argvs[0], "&lt;string&gt;"
        exit()

    filepath = argvs[1]
    f = open(filepath)
    p1 = re.compile(r"(?:https?|ftp):\/\/[A-Za-z0-9\.-]*")  #文字列全体からURLを抽出

    m = p1.findall(f.read())

    if len(m) is 0:
        print "no match..."
    else:
        for n in m:
            print re.sub(r'(?:https?|ftp):\/\/', '' , n)    #置換

if __name__ == "__main__":
    main()</pre>


<p>置換えのメソッドはsubです。 上記のサンプルではreクラスからsub呼び出していますが、マッチングのためのインスタンスを生成して、インスタンスからsubメソッドを呼び出すこともできます。</p>

<pre class="lang:default decode:true">str = argvs[1]
    p1 = re.compile(r"(?:https?|ftp):\/\/")
        print p1.sub('', str)</pre>


<p>プロトコルの部分だけをマッチングさせるインスタンスを別途作成しました。これもうちょっと簡単にする方法あるかな・・・・。</p>

<p>正規表現に関しては個人的にはRubyのほうが直感的で使いやすいかも。</p>

<p>&nbsp;</p>

<p>基礎的な部分なんだけど、使いたいときにサッと出てこないことが多かったので、以上メモです。入門の入門的な。</p>

<p>&nbsp;</p>

<p>追記</p>

<p>４．おまけ　Python &amp; Ruby　リストの重複を排除する</p>

<p>上記の項目３で、指定したファイルからドメインを抽出するスクリプトを書きましたが、重複したドメインが表示されてしまいます。試しにfacebookのトップページからドメインを抽出してみたところ、膨大な重複が検出されました。（当たり前だけど）</p>

<p>そこでそれぞれ重複を排除し、利用されているドメインの一覧を表示するように変更します。</p>

<p>[Rubyにおける重複の排除]</p>

<pre class="lang:ruby decode:true">ms.uniq!</pre>


<p>もともとのインスタンス(この場合 変数ms)の状態を残しておきたければ最後の！マークを取って変数に代入すればOKです（破壊的メソッドか、否か）</p>

<p>&nbsp;</p>

<p>[Pythonにおける重複の排除]</p>

<pre class="lang:python decode:true">l = list(set(m))</pre>


<p>pythonの場合は一件ちょっと複雑ですが、もともとのリスト（変数m）を重複を持たないデータ構造のsetへ変換（set()関数で）</p>

<p>それからlist()関数でlistへ変換。別にset()のままでもいい時はset(m)だけでもいいと思います。</p>

<p>&nbsp;</p>

<p>これを抽出したドメインのリストに対して処理すれば、すべてユニークになります。</p>

<p>&nbsp;</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">k.komai</span></span>

      








  


<time datetime="2013-05-29T00:00:00+09:00" pubdate data-updated="true"></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/wei-fen-lei/'>未分類</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://KentaKomai.github.io/blog/2013/05/29/wordpress39/" data-via="TAMAGO_MAGO_2" data-counturl="http://KentaKomai.github.io/blog/2013/05/29/wordpress39/" >Tweet</a>
  
  
  
    <div class="fb-like" data-send="true" data-width="450" data-show-faces="false"></div>
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2013/05/16/wordpress38/" title="Previous Post: python2.x系でfor文でrange()を使う際に気をつけたいこと">&laquo; python2.x系でfor文でrange()を使う際に気をつけたいこと</a>
      
      
        <a class="basic-alignment right" href="/blog/2013/06/02/wordpress40/" title="Next Post: Raspberry Piにkali Linux入れて動かしてみる（＋日本語キーボードレイアウト適用）">Raspberry Piにkali Linux入れて動かしてみる（＋日本語キーボードレイアウト適用） &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/11/28/wordpress77/">簡易プロセス死活監視プログラムをc#で</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/25/wordpress76/">xv6のソースコードとテキストを読んでみる1_chapter0_2</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/19/wordpress75/">[CSCamp CTF]解けなかった問題forensics1のwriteupを読んでみた</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/18/wordpress74/">Vagrant + Chef solo + Berkshelfを試してみたのでまとめ</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/11/10/wordpress73/">xv6のソースコードとテキストを読んでみる1_chapter0_1</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 -  Kenta Komai <br/>
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> + <a href="https://github.com/ioveracker/mnml">mnml</a>.
	  
  </span>
</p>

</footer>
  



<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id; js.async = true;
  js.src = "//connect.facebook.net/en_US/all.js#appId=212934732101925&xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>





  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
